并查集（Disjoint Set）是一种精巧而实用的数据结构，主要用于处理一些不相交集合的合并问题
经典应用：连通图，最小生成树Kruskal算法，最近公共祖先（LCA）
基本操作：初始化，合并，查找，统计

### 1，初始化

定义数组 `s[]`，`s[i]`是元素i所属的并查集，开始时未处理任何节点关系，所以每个点都属于独立的集，直接以元素i的值表示它的集`s[i]`的值，如元素1的集：`s[i]=1`

| s[i] | 1   | 2   | 3   | ... |
| ---- | --- | --- | --- | --- |
| i    | 1   | 2   | 3   | ... |

### 2，合并
（1）加入第一个节点（`s[1]`）关系，在并查集s中把节点1合并到节点2，也就是把节点1的集改为节点2的集

| s[i] | 2   | 2   | 3   | ... |
| ---- | --- | --- | --- | --- |
| i    | 1   | 2   | 3   | ... |
（2）加入第二个节点关系查找结点1的集：2，在递归查找节点2的集：2，然后再把节点2的集合并到节点3的集：3

| s[i] | 3   | 3   | 3   | ... |
| ---- | --- | --- | --- | --- |
| i    | 1   | 2   | 3   | ... |

### 3，查找
上边合并中已有查找的操作。查找元素是个**递归**的过程，直到元素的值和它的集相等，就找到了根节点的集
**搜索树的高度可能很大**，复杂度为O(n)

### 4，统计
如果`s[i] = i`，这就是个根节点，是它所在集的代表；统计根节点的数量，就是集的数量。

## 模板
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 10005;

  

int s[N];

  

void init_set() // 初始化

{

    for (int i = 1; i<=N; i++)

    {

        s[i] = i;

    }

}

  

int find_set(int x) // 查找

{

    return x == s[x] ? x : find_set(s[x]);

}

  

void merge_set(int x, int y) // 合并

{

    x = find_set(x); y = find_set(y);

    if (x != y) s[x] = s[y];

}

  

int count_set(int n) // 统计集

{

    int ans = 0;

  

    for (int i = 1; i<=n; i++)

    {

        if (s[i] == i) ans ++;

    }

  

    return ans;

}
```